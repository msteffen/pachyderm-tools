package main

import (
	"bytes"
	"fmt"
	"math/rand"
	"os"
	p "path"
	"strings"
	"testing"
	"time"
)

var testRand = rand.New(rand.NewSource(7))

func Check(t testing.TB, b bool, args ...interface{}) {
	t.Helper()
	if !b {
		t.Fatalf(args[0].(string), args[1:]...)
	}
}

func CheckEq(t testing.TB, got, want interface{}) {
	t.Helper()
	if wantpaths, ok := want.(paths); ok {
		gotpaths, ok := got.(paths)
		if !ok {
			t.Fatalf("wanted value of type 'paths', but got %T", got)
		}
		CheckNil(t, wantpaths.ConfirmEq(gotpaths))
		return
	}
	Check(t, got == want, "Expected %v\n   But got %v", want, got)
}

func CheckNil(t testing.TB, err error) {
	t.Helper()
	CheckEq(t, err, error(nil))
}

func CheckNotNil(t testing.TB, err error) {
	t.Helper()
	if err == nil {
		t.Fatal("Expected err to be non-nil, but was 'nil'")
	}
}

type paths map[string]struct{}

func (d paths) String() string {
	var buf bytes.Buffer
	var sep string
	for k := range d {
		buf.WriteString(sep)
		buf.WriteString(k)
		sep = ", "
	}
	return buf.String()
}

// ConfirmEq returns 'nil' if 'd' and 'other' are equal, or an error otherwise
func (d paths) ConfirmEq(other paths) error {
	if len(other) != len(d) {
		// slight abuse of error, but this only really used by tests
		return fmt.Errorf("expected 'paths' of size %d, but was %d:\n%v\n%v",
			len(d), len(other), d, other)
	}
	for k := range d {
		if _, ok := other[k]; !ok {
			return fmt.Errorf("expected %q, but didn't find it:\n%v", k, other)
		}
	}
	return nil // success
}

func (d paths) Copy() paths {
	var result paths = make(map[string]struct{})
	for s := range d {
		result[s] = struct{}{}
	}
	return result
}

func (d paths) Add(path string) {
	for path = p.Clean(path); path != ""; path = p.Dir(path) {
		if _, ok := d[path]; ok {
			break // all other parents have been added
		}
		d[path] = struct{}{}
	}
}

func (d paths) Rm(path string) {
	for f := range d {
		if strings.HasPrefix(f, path) {
			delete(d, f)
		}
	}
}

func (d paths) Pick(except ...string) string {
	exceptM := make(map[string]struct{})
	for _, e := range except {
		exceptM[e] = struct{}{}
	}

	i := testRand.Int31n(int32(len(d) - len(exceptM)))
	var f string
	for f = range d {
		if _, ok := exceptM[f]; ok {
			continue
		}
		if i--; i < 0 { // i < 0 => i == 0 at the start (i \in [0, n) )
			break
		}
	}
	return f
}

func TestError(t *testing.T) {
	CheckNil(t, os.RemoveAll("base"))
	os.Mkdir("base", 0755)
	go func() {
		time.Sleep(time.Second) // yield control to calling goro
		os.Mkdir("base/dir", 0755)
	}()
	err := Watch("./base", func(e WatchEvent) error {
		if e.Path != "base/dir" {
			return fmt.Errorf("unwanted event: %s", e)
		}
		return fmt.Errorf("expected error")
	})
	CheckNotNil(t, err)
	CheckEq(t, err.Error(), "expected error")
}

func TestErrorDeleteRoot(t *testing.T) {
	CheckNil(t, os.RemoveAll("base"))
	os.Mkdir("base", 0755)
	go func() {
		time.Sleep(time.Second) // yield control to calling goro
		os.Remove("base")
	}()
	err := Watch("./base", func(e WatchEvent) error {
		return nil
	})
	CheckNotNil(t, err)
	CheckEq(t, err.Error(), "watch root \"base\" has been deleted")
}

func TestErrorNoRoot(t *testing.T) {
	CheckNil(t, os.RemoveAll("base"))
	err := Watch("./base", func(e WatchEvent) error {
		return nil
	})
	CheckNotNil(t, err)
	CheckEq(t, err.Error(), "could not Stat() watch target \"base\": "+
		"stat base: no such file or directory")
}

func TestFuzz(t *testing.T) {
	CheckNil(t, os.RemoveAll("base"))
	var expected paths = map[string]struct{}{
		"base": struct{}{},
	}
	actual := expected.Copy()
	expectedStateCh := make(chan paths)

	// Randomly modify "./base" and make sure modifications are picked up by Watch
	go func() {
		time.Sleep(time.Second) // yield to calling goro
		for i := 0; i < 100; i++ {
			if len(expected) == 1 || testRand.Int31n(2) > 0 {
				baby := p.Join(expected.Pick(), fmt.Sprintf("%03d", i))
				CheckNil(t, os.Mkdir(baby, 0755))
				expected.Add(baby)
			} else {
				dead := expected.Pick( /* except */ "base")
				CheckNil(t, os.RemoveAll(dead))
				expected.Rm(dead)
			}
			expectedStateCh <- expected.Copy()

			// insert dummy value into channel; this line blocks until the target
			// state has been reached so the next change can be applied (or close the
			// channel if we're done)
			if i+1 < 100 {
				expectedStateCh <- nil
			} else {
				close(expectedStateCh)
			}
		}
	}()

	// Initiate Watch
	// N.B. we pass WatchEvents through a channel because a single operation above
	// may generate multiple events (e.g. "delete foo/" would generate Delete
	// events for "foo/a/", "foo/b/", and "foo/c/"), and we want to apply all
	// events generated by a single operation before comparing end states.
	CheckNil(t, os.Mkdir("base", 0755))
	eventCh := make(chan WatchEvent)
	go func() {
		err := Watch("base", func(e WatchEvent) error {
			if e.Type != Create && e.Type != Delete {
				return fmt.Errorf("unexpected event: %s", e)
			}
			eventCh <- e
			return nil
		})
		CheckEq(t, err.Error(), "watch root \"base\" has been deleted")
	}()

	// read through expected states and try to reach each one--note that
	// filesystem modifications are blocked on each expected state being reached
	// (roughly -- real FS is typically one step ahead) so there's no way for some
	// random run of deletes to mask the fact that a particular state was never
	// reached
	target, ok := <-expectedStateCh
	for {
		// Apply pending watch events until there are none left
		select {
		case e := <-eventCh:
			if e.Type == Create {
				actual.Add(e.Path)
			} else if e.Type == Delete {
				actual.Rm(e.Path)
			} else {
				t.Fatalf("unexpected event type: " + e.String())
			}
			continue
		case <-time.After(100 * time.Millisecond):
			break // no more events arriving
		}
		// Make sure Watch events put 'actual' into the right target state
		CheckEq(t, actual, target)

		// pull dummy state out of channel to unblock generator goro (or exit)
		if _, ok = <-expectedStateCh; !ok {
			break
		}
		// Wait for new expected state
		target, ok = <-expectedStateCh
	}
}

// TestFuzzAsync is similar to TestFuzz, but the goroutine that generates events
// doesn't wait for the gorouting that receieves events to catch up before
// continuing. Because of that, this test is more lax--it's very easy for events
// to be re-ordered (because watches take a non-trivial amount of time to
// establish) so instead of checking every state, we just confirm that every
// create and every delete is seen in some order.
//
// The main benefit of this test over TestFuzz is that it's good at confirming
// that Watch() doesn't have any race conditions with files being deleted
// shortly after being created that cause it to panic.
func TestFuzzAsync(t *testing.T) {
	CheckNil(t, os.RemoveAll("base"))
	var expected paths = map[string]struct{}{
		"base": struct{}{},
	}

	// Randomly modify "./base" and make sure modifications are picked up by Watch
	expectedCreates, expectedDeletes := make(paths), make(paths)
	done := make(chan struct{})
	go func() {
		time.Sleep(time.Second) // yield to calling goro
		for i := 0; i < 100; i++ {
			if len(expected) == 1 || testRand.Int31n(2) > 0 {
				baby := p.Join(expected.Pick(), fmt.Sprintf("%03d", i))
				CheckNil(t, os.Mkdir(baby, 0755))
				expected.Add(baby)
				expectedCreates.Add(baby)
			} else {
				dead := expected.Pick( /* except */ "base")
				CheckNil(t, os.RemoveAll(dead))
				for path := range expected {
					if strings.HasPrefix(path, dead) {
						expectedDeletes.Add(path) // inotify generates events for children
					}
				}
				expected.Rm(dead)
			}
			// hack -- briefly yield control; if a dir is created and deleted before
			// the watcher can even scan its parent, it might not generate an event
			// and this test would break
			time.Sleep(time.Millisecond)
		}
		close(done)
	}()

	// Initiate Watch
	// TODO(msteffen) right now there's no way to cancel a watch (in part becase
	// there's no way to timeout of the read() syscall that it waits on). So just
	// leak a goro.
	actualCreates, actualDeletes := make(paths), make(paths)
	CheckNil(t, os.Mkdir("base", 0755))
	go func() {
		err := Watch("base", func(e WatchEvent) error {
			// Apply pending watch events until we match 'expected'
			if e.Type == Create {
				actualCreates.Add(e.Path)
			} else if e.Type == Delete {
				actualDeletes.Add(e.Path)
			} else {
				t.Fatalf("unexpected event type: " + e.String())
			}
			return nil
		})
		CheckEq(t, err.Error(), "watch root \"base\" has been deleted")
	}()

	<-done
	time.Sleep(time.Second) // hack -- wait for pending WatchEvents to be applied
	CheckEq(t, actualCreates, expectedCreates)
	CheckEq(t, actualDeletes, expectedDeletes)
}

func TestFiles(t *testing.T) {
	CheckNil(t, os.RemoveAll("base"))
	done := make(chan struct{})

	// Randomly modify "./base" and make sure modifications are picked up by Watch
	expectedCreates, expectedModifications := make(paths), make(paths)
	go func() {
		time.Sleep(time.Second) // yield to calling goro
		for i := 0; i < 100; i++ {
			baby := fmt.Sprintf("base/%03d", i)
			f, err := os.Create(baby)
			CheckNil(t, err)
			CheckNil(t, f.Close())
			expectedCreates.Add(baby)
		}
		for i := 0; i < 100; i++ {
			adult := fmt.Sprintf("base/%03d", i)
			f, err := os.OpenFile(adult, os.O_WRONLY|os.O_APPEND, 0)
			CheckNil(t, err)
			f.Write([]byte("x"))
			CheckNil(t, f.Close())
			expectedModifications.Add(adult)
		}
		close(done)
	}()

	// Initiate Watch
	actualCreates, actualModifications := make(paths), make(paths)
	CheckNil(t, os.Mkdir("base", 0755))
	go func() {
		err := Watch("base", func(e WatchEvent) error {
			// Apply pending watch events until we match 'expected'
			if e.Type == Create {
				actualCreates.Add(e.Path)
			} else if e.Type == Modify {
				actualModifications.Add(e.Path)
			} else {
				t.Fatalf("unexpected event type: " + e.String())
			}
			return nil
		})
		CheckEq(t, err.Error(), "watch root \"base\" has been deleted")
	}()

	<-done
	time.Sleep(time.Second) // hack -- wait for pending WatchEvents to be applied
	CheckEq(t, actualCreates, expectedCreates)
	CheckEq(t, actualModifications, expectedModifications)
}
